vocabulary PacmanVoc{

	type dir //We guarantee you that dir, Left, Right, Up, Down will always be correctly interpreted in structures. You should not check this.
	Down: dir
	Left: dir
	Right: dir
	Up: dir

	type xCo isa int
	type yCo isa int

	type agent //The ghosts and pacman
	pacman:agent

	Pos(xCo,yCo)
	NoPos(xCo,yCo) 
	Wall(xCo,yCo,dir)


	/*Van wat hieronder staat kan een deel gegeven zijn, een deel gevraagd*/
	Gold(xCo,yCo)
	GameLost
	GameWon
	GameEnded
	Position(agent,xCo,yCo)
	
	PreviousMove(agent,dir)
	Move(agent,dir)

	//Eigen predicaten
	Reach(xCo,yCo,xCo,yCo)
	OppositeDir(dir,dir)
	Transition(dir,xCo,yCo,xCo,yCo)
	

}

theory PacmanTheory:PacmanVoc{
	// Transition, de relatie tussen verandering van coordinaten en richting
	! x[xCo] : ! y[yCo] : Transition(Right,x,y,x+1,y) & Transition(Left,x,y,(-1+x),y)
						& Transition(Up,x,y,x,y+1) & Transition(Down,x,y,x,-1+y).
						
	// OpositeDirection, uitdrukken dat twee richtingen elkaars tegengestelden zijn
	! x1[xCo],y1[yCo],x2[xCo],y2[yCo] : ! d1[dir],d2[dir] : ( Transition(d1,x1,y1,x2,y2) & Transition(d2,x2,y2,x1,y1) )
																=> OppositeDir(d1,d2).
	
	// GameEnded: Het spel is gedaan, het is verloren of gewonnen
	GameEnded<=>(GameLost|GameWon).
	
	// Pos: Een positie waar wel een vakje is
	!x[xCo],y[yCo]:Pos(x,y)<=>~NoPos(x,y).
	
	// Wall predicaat symmetrisch maken
	//! y1[yCo],y2[yCo] : Wall(x,y1,Down) & y2=-1+y1 <=> Wall(x,y2,Up).
	//! y1[yCo],y2[yCo] : Wall(x,y1,Up) & y2=1+y1 => Wall(x,y2,Down).
	//! x1[xCo],x2[xCo] : Wall(x1,y,Right) & x2=-1+x1 <=> Wall(x2,y,Left).
	//! x1[xCo],x2[xCo] : Wall(x1,y,Left) & x2=1+x1 => Wall(x2,y,Right).
	! x1[xCo],y1[yCo],x2[xCo],y2[yCo] : ! d1[dir],d2[dir] : 
									( Wall(x1,y1,d1) & Transition(d1,x1,y1,x2,y2) & OppositeDir(d1,d2) )
									=> Wall(x2,y2,d2).
	
	// Alle vakjes zijn aaneengesloten
	//! x1[xCo],y1[yCo],x2[xCo],y2[yCo] : ReachInStep(x1,y1,x2,y2) <=> ( (x1=x2+1 & ~Wall(x1,y1,Right))
	//																	| (y1=y2+1 & ~Wall(x1,y1,Up)) ).
	//! x1[xCo],y1[yCo],x2[xCo],y2[yCo] : ReachInStep(x1,y1,x2,y2) <=> ReachInStep(x2,y2,x1,y1).
	{
		! x1[xCo],y1[yCo],x2[xCo],y2[yCo] : Reach(x1,y1,x2,y2) <- ? d[dir] :Transition(d,x1,y1,x2,y2).
		! x1[xCo],y1[yCo],x2[xCo],y2[yCo] : Reach(x1,y1,x2,y2) <- ? x3[xCo], y3[yCo] : Reach(x1,y1,x3,y3) & Reach(x3,y3,x2,y2).
	}
	
	// GameLost en GameWon hebben de juiste interpretatie in functie v d andere predicaten
	~ (? x[xCo],y[yCo] : Gold(x,y)) <=> GameWon.
	(? x[xCo],y[yCo], a[agent]: Position(pacman,x,y) & Position(a,x,y) & ~a=pacman)<=>GameLost.
	
	// Iedereen is op exact 1 plaats
	!x1[xCo],x2[xCo],y1[yCo],y2[yCo],a[agent]:((Position(a,x1,y1)&Position(a,x2,y2))=>(x1=x2&y1=y2)).
	
	// Niemand staat op plaatsen waar geen vakje is
	!x[xCo],y[yCo]:(Position(_,x,y)=>~NoPos(x,y)).
	
	// Er kan enkel goud liggen op plaatsen waar een vakje is
	! x[xCo],y[yCo] : Gold(x,y) => ~NoPos(x,y).
	
	// Niemand beweegt door muren
	! x[xCo],y[yCo],a[agent],d[dir]:(Wall(x,y,d)&Position(a,x,y)=>~Move(a,d)).
	
	// Iedereen kan hoogstens in 1 richting tegelijk bewegen
	! a[agent] : ! d1[dir],d2[dir] : ( Move(a,d1) & Move(a,d2) ) => d1=d2.
	
	// Ghosts kunnen niet omkeren
	//OppositeDir(Right,Left).
	//OppositeDir(Up,Down).
	//! d1[dir],d2[dir] : OppositeDir(d1,d2) <=> OppositeDir(d2,d1).
	! a[agent] : ! d [dir] : ! prevD [dir] : a=pacman | ( ( Move(a,d) & PreviousMove(a,prevD) ) => ~OppositeDir(d,prevD) ).
	
	// Pacman laat geen goud liggen.
	! x1[xCo],y1[yCo],x2[xCo],y2[yCo] : ! d[dir] : ( PreviousMove(pacman,d) & Transition(d,x1,y1,x2,y2) & Position(pacman,x2,y2) ) 
															=> ~Gold(x1,y1).

	// Afhankelijk van of het spel al gedaan is moet iedereen bewegen/mag niemand bewegen
	GameEnded<=>~(?a[agent]:Move(a,_)).
	
	// Niemand beweegt van het bord af
	!a[agent],x[xCo],y[yCo],d[dir]:Position(a,x,y)&Move(a,d)&Transition(d,x,y,x2,y2)=>Pos(x2,y2).
}


