/**
 * Title: A new IDP source file
 * Author: jessa
 */


vocabulary PacmanVoc{

	type dir //We guarantee you that dir, Left, Right, Up, Down will always be correctly interpreted in structures. You should not check this.
	Down: dir
	Left: dir
	Right: dir
	Up: dir

	type xCo isa int
	type yCo isa int

	type agent //The ghosts and pacman
	pacman:agent

	NoPos(xCo,yCo) 
	Wall(xCo,yCo,dir)


	/*Van wat hieronder staat kan een deel gegeven zijn, een deel gevraagd*/
	Gold(xCo,yCo)
	GameLost
	GameWon
	Position(agent,xCo,yCo)
	
	PreviousMove(agent,dir)
	Move(agent,dir)
	
	/* Eigen predicaten */
	Transition(dir,xCo,yCo,xCo,yCo)
	OppositeDir(dir):dir
	IsWall(xCo,yCo,dir)
	Reach(xCo,yCo,xCo,yCo)
	Pos(xCo,yCo)
	GameEnded

}

theory PacmanTheory:PacmanVoc{
	// Transition, de relatie tussen verandering van coordinaten en richting.
	// Impliciet, wanneer er een transition bestaat, liggen twee vakjes naast elkaar.
	{
	!x1[xCo], y1[yCo], x2[xCo], y2[yCo]: Transition(Down ,x1,y1,x2,y2) <- x2=x1 & y2=-1+y1.
	!x1[xCo], y1[yCo], x2[xCo], y2[yCo]: Transition(Up   ,x1,y1,x2,y2) <- x2=x1 & y2= 1+y1.
	!x1[xCo], y1[yCo], x2[xCo], y2[yCo]: Transition(Left ,x1,y1,x2,y2) <- x2=-1+x1 & y2=y1.
	!x1[xCo], y1[yCo], x2[xCo], y2[yCo]: Transition(Right,x1,y1,x2,y2) <- x2= 1+x1 & y2=y1.
	}
							
	// OpositeDirection, uitdrukken dat twee richtingen elkaars tegengestellenden zijn
		OppositeDir(Left)=Right.
		OppositeDir(Up)=Down.
		!d[dir]:OppositeDir(OppositeDir(d))=d.
		
	// GameEnded: Het spel is gedaan, het is verloren of gewonnen
	GameEnded<=>GameLost|GameWon.
	
	// Pos: Een positie waar wel een vakje is
	{
	!x[xCo],y[yCo]:Pos(x,y)<-~NoPos(x,y).
	}
	
	// Wall predicaat symmetrisch maken
	{
		!x[xCo],y[yCo],d[dir]: IsWall(x,y,d) <- Wall(x,y,d).
		!x2[xCo],y2[yCo],d[dir]: IsWall(x2,y2,OppositeDir(d)) <- ?x1[xCo],y1[yCo]: IsWall(x1,y1,d) & Transition(d,x1,y1,x2,y2).
	}
	

	// Alle vakjes zijn aaneengesloten
	{
		! x[xCo],y[yCo] : Reach(x,y,x,y) <-Pos(x,y).
		! x1[xCo],y1[yCo],x2[xCo],y2[yCo] : Reach(x1,y1,x2,y2) <- ? d[dir] :Transition(d,x1,y1,x2,y2) 
																		& ~IsWall(x1,y1,d) & Pos(x1,y1) & Pos(x2,y2).
		! x1[xCo],y1[yCo],x2[xCo],y2[yCo] : Reach(x1,y1,x2,y2) <- ?x3[xCo],y3[yCo]:Reach(x1,y1,x3,y3)&Reach(x3,y3,x2,y2).
	}
	!x1[xCo],y1[yCo],x2[xCo],y2[yCo]:Pos(x1,y1)&Pos(x2,y2)<=>Reach(x1,y1,x2,y2).
	
	// GameLost en GameWon hebben de juiste interpretatie in functie v d andere predicaten
	~GameLost & ~ (? x[xCo],y[yCo] : Gold(x,y)) <=> GameWon.
	(? x[xCo],y[yCo], a[agent]: Position(pacman,x,y) & Position(a,x,y) & ~a=pacman)<=>GameLost.
	
	// Iedereen is op exact 1 plaats
	!a[agent]:?x[xCo],y[yCo]:Position(a,x,y).
	!a[agent],x1[xCo],y1[yCo],x2[xCo],y2[yCo]:Position(a,x1,y1)&Position(a,x2,y2)
			=> x1=x2&y1=y2.
	
	// Niemand staat op plaatsen waar geen vakje is
	!a[agent],x[xCo],y[yCo]:Position(a,x,y)=>Pos(x,y).
	
	// Er kan enkel goud liggen op plaatsen waar een vakje is
	! x[xCo],y[yCo] : Gold(x,y) => Pos(x,y).
	
	// Niemand beweegt door muren
	! x[xCo],y[yCo],a[agent],d[dir]:(IsWall(x,y,d)&Position(a,x,y)=>~Move(a,d)).
	
	// Iedereen kan hoogstens in 1 richting tegelijk bewegen
	! a[agent] : ! d1[dir],d2[dir] : ( Move(a,d1) & Move(a,d2) ) => d1=d2.
	! a[agent] : ! d1[dir],d2[dir] : ( PreviousMove(a,d1) & PreviousMove(a,d2) ) => d1=d2. /*in dynamisch systeem is dit geimpliceerd */
	
	// Ghosts kunnen niet omkeren
	! a[agent],d [dir], prevD[dir] : a=pacman | ( Move(a,d) & PreviousMove(a,prevD)=>~prevD=OppositeDir(d)).
	
	// Pacman laat geen goud liggen.
	!p[agent],d[dir],x1[xCo],y1[yCo],x2[xCo],y2[yCo]:p=pacman&PreviousMove(p,d)&Position(p,x2,y2)&Transition(d,x1,y1,x2,y2)
				=> ~Gold(x1,y1).

	// Afhankelijk van of het spel al gedaan is moet iedereen bewegen/mag niemand bewegen
	GameEnded<=>~?a[agent],d[dir]:Move(a,d).
	~GameEnded<=>!a[agent]:?d[dir]:Move(a,d).
	
	// Niemand beweegt van het bord af
	!a[agent],x1[xCo],y1[yCo],d[dir]:Position(a,x1,y1)&Move(a,d)=>?x2[xCo],y2[yCo]:Transition(d,x1,y1,x2,y2)&Pos(x2,y2).
}



 
 

/*
Some instance for the time-independent Pacman game.
*/
include <mx>


procedure eigenTests() {
	local strucs = {
		{"turning ghost",turnGhost},
		{"OneMoveDirection",oneMoveDir} ,
		{"allPos",allPos} ,
		{"mini",mini} ,
		//specifieke tests
		{"win",winSituation,},
		{"lose", lostSituation},
		{"winlose", winLostSituation},
		{"findPositionsNormal", findPositionsNormal},
		{"findPositionsWin", findPositionsWin},
		{"findPositionsLose", findPositionsLose},
		{"goldNoPos",goldNoPos1},
		{"moveTroughWall",moveTroughWall},
		{"moveMultipleDirections",moveMultipleDirections},
		{"ghostTurnBack",ghostTurnBack},
		{"pacmanTurnBack",pacmanTurnBack},
		{"pacmanLeavesGold", pacmanLeavesGold},
		{"gameEndedMove", gameEndedMove},
		{"gameNotEndedNoMove",gameNotEndedNoMove},
		{"moveToNoPos",moveToNoPos},
		{"moveOutsideDomain",moveOutsideDomain},
		{"noGoldLeft",noGoldLeft},
		{"goldNoPos",goldNoPos},
	}
	
	
//	printcore(PacmanTheory,strucs[1][2])
	
	for i=1, #strucs do
	print("executing ", strucs[i][1])
	local models = modelexpand(PacmanTheory, strucs[i][2])
	//printcore(PacmanTheory,strucs[i][2])
	printmodels(models)
	end
	
}





structure noGoldLeft : PacmanVoc{
	//unsatisfiable
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..4}
	yCo = {1..4}

	pacman=p
	agent={p; Blinky; }
	PreviousMove={p,u;Blinky,u;}

	NoPos = {1,1; 1,2; 4,1; 4,2; 4,3; }
	Position<ct> = {p,2,3}

	Wall = {2,2,d}
	
	Gold={2,2}
}

structure goldNoPos: PacmanVoc{
	//unsatisfiable
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..4}
	yCo = {1..4}

	pacman=p
	agent={p; Blinky; }
	PreviousMove={p,u;Blinky,u;}

	NoPos = {1,1; 1,2; 4,1; 4,2; 4,3; }
	Position<ct> = {p,2,3}

	Wall = {2,2,d}
	
	Gold={1,2}
}


structure turnGhost : PacmanVoc{
	// unsatisfiable
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..4}
	yCo = {1..4}

	pacman=p
	agent={p; Blinky; Pinky; Inky; Clyde}
	PreviousMove={p,d;Blinky,d;Pinky,d;Inky,d;Clyde,d}
	Move={Pinky,u}

	NoPos = {}

	Wall = {2,2,r}

}


structure oneMoveDir : PacmanVoc{
	// pinky should not move up
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..4}
	yCo = {1..4}

	pacman=p
	agent={p;Pinky}
	PreviousMove ={Pinky,d}


	NoPos = {}

	Wall = {2,2,r}

}


structure allPos : PacmanVoc{
	//all positions should be reachable
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..4}
	yCo = {1..4}

	pacman=p
	agent={p; Blinky; Pinky; Inky; Clyde}
	PreviousMove={p,d;Blinky,d;Pinky,d;Inky,d;Clyde,d}

	NoPos = {}

	Wall = {2,2,r}

}


structure mini : PacmanVoc{
	// all positions should be reachable 
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..3}
	yCo = {1}

	pacman=p
	agent={p; Blinky; Pinky; Inky; Clyde}
	PreviousMove={p,d;Blinky,d;Pinky,d;Inky,d;Clyde,d}

	NoPos = {}

	Wall = {1,1,l}

}




structure moveOutsideDomain: PacmanVoc {
	//unsatisfiable
	
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..3}
	yCo = {1..3}

	pacman=p
	agent={p; g}
	
	Position={p,2,2;g,3,2}
	
	Move = {p,u;g,r}
	PreviousMove = {p,d;g,r}

}


structure moveToNoPos: PacmanVoc {
	//unsatisfiable
	
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..3}
	yCo = {1..3}

	pacman=p
	agent={p; g}
	
	Position={p,2,2;g,3,2}
	
	Move = {p,u;g,d}
	PreviousMove = {p,d;g,r}

	NoPos={3,1}
}

structure gameNotEndedNoMove: PacmanVoc {
	//unsatisfiable
	
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..3}
	yCo = {1..3}

	pacman=p
	agent={p; g}
	
	Position={p,2,2;g,3,2}
	
	Move = {p,u}
	PreviousMove = {p,d;g,r}

	GameEnded = false
}


structure gameEndedMove: PacmanVoc {
	//unsatisfiable
	
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..3}
	yCo = {1..3}

	pacman=p
	agent={p; g}
	
	Position={p,2,2;g,3,2}
	
	Move = {p,u}
	PreviousMove = {p,d;g,r}

	GameEnded = true
}

structure pacmanLeavesGold: PacmanVoc {
	//unsatisfiable
	
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..3}
	yCo = {1..3}

	pacman=p
	agent={p; g}
	
	Position={p,2,2;g,3,2}
	
	Move = {p,u;g,d}
	PreviousMove = {p,d;g,r}

	Gold={2,3}
}


structure pacmanTurnBack: PacmanVoc {
	//satisfiable
	
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..3}
	yCo = {1..3}

	pacman=p
	agent={p; g}
	
	Position={p,2,2;g,3,2}
	
	Move = {p,u;g,d}
	PreviousMove = {p,d;g,r}

}

structure ghostTurnBack: PacmanVoc {
	//unsatisfiable
	
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..3}
	yCo = {1..3}

	pacman=p
	agent={p; g}
	
	Position={p,2,2;g,3,2}
	
	Move = {p,u;g,d}
	PreviousMove = {p,r;g,u}

}

structure moveMultipleDirections: PacmanVoc {
	//unsatisfiable
	
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..3}
	yCo = {1..3}

	pacman=p
	agent={p; }
	
	Position={p,2,2}
	
	Move = {p,u;p,d}

	
	GameEnded=false

}

structure winSituation: PacmanVoc {
	// goal: GameWon = true
	
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..4}
	yCo = {1..4}

	pacman=p
	agent={p; Blinky;}
	PreviousMove={p,d;Blinky,d;}
	Position={p,2,2;Blinky,3,3}

	NoPos = {1,1;1,2;1,3;1,4;2,1;2,4;3,1;3,2;4,1;4,2;4,3;4,4}
	
	Gold = {}

	Wall = {2,2,r}
}

structure lostSituation: PacmanVoc {
	// goal: GameLost = true
	
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..4}
	yCo = {1..4}

	pacman=p
	agent={p; Blinky;}
	PreviousMove={p,d;Blinky,d;}
	Position={p,2,2;Blinky,2,2}

	NoPos = {1,1;1,2;1,3;1,4;2,1;2,4;3,1;3,4;4,1;4,2;4,3;4,4}
	
	Gold = {3,3}

	Wall = {2,2,r}
}

structure winLostSituation: PacmanVoc {
	// goal: GameLost = true
	
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..4}
	yCo = {1..4}

	pacman=p
	agent={p; Blinky;}
	PreviousMove={p,d;Blinky,d;}
	Position={p,2,2;Blinky,2,2}

	NoPos = {1,1;1,2;1,3;1,4;2,1;2,4;3,1;3,2;4,1;4,2;4,3;4,4}
	
	Gold = {}

	Wall = {2,2,r}
}

structure findPositionsNormal: PacmanVoc {
	// find positions
	
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..4}
	yCo = {1..4}

	pacman=p
	agent={p; Blinky;}

	NoPos = {1,1;1,2;1,3;1,4;2,1;2,4;3,1;4,1;4,2;4,3;4,4}
	
	GameEnded=false
	
	Gold = {2,2;3,3}

	Wall = {2,2,r}
	
}


structure findPositionsWin: PacmanVoc {
	//find positions in such a way that the game is won:
	//No gold is present anymore
	//pacman and blinky are not in the same position
	
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..4}
	yCo = {1..4}

	pacman=p
	agent={p; Blinky;}

	NoPos = {1,1;1,2;1,3;1,4;2,1;2,4;3,1;3,2;4,1;4,2;4,3;4,4}
	
	GameWon=true

	Wall = {2,2,r}
}


structure findPositionsLose: PacmanVoc {
	//find positions in such a way that the game is won:
	//presence of gold is not important
	//pacman and blinky are in the same position
	
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..4}
	yCo = {1..4}

	pacman=p
	agent={p; Blinky;}

	NoPos = {1,1;1,2;1,3;1,4;2,1;2,4;3,1;3,2;4,1;4,2;4,3;4,4}
	
//	Gold = {2,2;3,2}
	
	GameLost=true

	Wall = {2,2,r}
}



structure goldNoPos1: PacmanVoc {
	// should be unsatisfiable
	
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..4}
	yCo = {1..4}

	pacman=p
	agent={p; Blinky;}

	NoPos = {1,1;1,2;1,3;1,4;2,1;2,4;3,1;4,1;4,2;4,3;4,4}
	
	GameEnded=false
	
	Gold = {2,2;3,3;4,4}

	Wall = {2,2,r}
	
}




structure moveTroughWall: PacmanVoc {
	//if move is commented: result is Move{p,d}
	//else unsatisfiable
	
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..3}
	yCo = {1..3}

	pacman=p
	agent={p; }
	
	Position={p,2,2}
	
	//Move = {p,u}

	
	GameEnded=false

	Wall = {2,2,r;2,2,l;2,2,u}
	
}




procedure check() {
	local strucs={
//		{split, "split", 0 } ,
//		{invalidGold, "invalidGold", 0}, 
//		{cheater2, "cheater2", 0 } ,
//		{cheater3, "cheater3", 0 } ,
		{huge, "huge", 2},
//		{winlose, "winlose", 0 } ,
//		{win, "win", 1 } ,
//		{lose, "lose", 1 } ,
	}


	stdoptions.liftedunitpropagation=false
	stdoptions.groundwithbounds=false
	
	
	for i = 1, #strucs do
		local curr = strucs[i]
		local struc = curr[1]
		local name = curr[2]
		local expected = curr[3]
		stdoptions.nbmodels = expected + 1
		print("Veryfing", name)
		//local models = modelexpand(PacmanTheory,curr[1])
		printcore(PacmanTheory,curr[1])
		local modelsfound = #models
		/*if modelsfound > expected then
			print(">>>>>>> Verification failed. Found too many models for", name)
			printmodels(models)
		elseif modelsfound < expected then
			print(">>>>>>> Verification failed. Found too few models for", name)
			printmodels(models)
		else
			print("Verification succeeded for", name)
		end*/
	end
	
	


}

structure split : PacmanVoc{
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..4}
	yCo = {1..4}

	pacman=p
	agent={p; Blinky; Pinky; Inky; Clyde}
	PreviousMove={p,d;Blinky,d;Pinky,d;Inky,d;Clyde,d}

	NoPos = {1,2;2,2;3,2;4,2}

	Wall = {}

}

structure invalidGold : PacmanVoc{
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..4}
	yCo = {1..4}

	pacman=p
	agent={p; Blinky; Pinky; Inky; Clyde}
	PreviousMove={p,d;Blinky,d;Pinky,d;Inky,d;Clyde,d}

	NoPos = {1,1; 1,2; 1,3; 1,4; 2,1; 4,3; 4,4; 2,4; 3,4}

	Wall = {}

	Gold={2,2;1,4}

}


structure cheater2 : PacmanVoc{
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..4}
	yCo = {1..4}

	pacman=p
	agent={p; Blinky; Pinky; Inky; Clyde}
	PreviousMove={p,d;Blinky,d;Pinky,d;Inky,d;Clyde,d}

	NoPos = {1,1; 1,2; 4,1; 4,2; 4,3; 4,4; 2,4; 3,4}

	Wall = {2,2,d}
	
	Position<ct> = {p,2,2}

	Move<ct> = {p,d}

	
}

structure cheater3 : PacmanVoc{
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..4}
	yCo = {1..4}

	pacman=p
	agent={p; Blinky; Pinky; Inky; Clyde}
	PreviousMove={p,d;Blinky,d;Pinky,d;Inky,d;Clyde,d}

	NoPos = {1,1; 1,2; 4,1; 4,2; 4,3; }

	Wall = {2,2,d}
	
	Position<ct> = {p,4,4}

	Move<ct> = {p,d}

	
}

structure huge : PacmanVoc{
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

        xCo = {1..12}
        yCo = {1..10}
        NoPos = {2,3;2,8;5,1;5,10;6,5;6,6;7,5;7,6;8,1;9,1;8,10;9,10}
        Wall = {
                        2,1,u; 2,4,u; 2,6,u; 2,9,u; 
                        3,1,u; 3,4,u; 3,6,u; 3,9,u; 3,5,u;
                        4,3,u; 4,5,u; 4,7,u;
                        5,3,u; 5,7,u;
                        6,2,u; 6,8,u;
                        7,2,u; 7,8,u;
                        8,3,u; 8,7,u;
                        9,2,u; 9,5,u; 9,8,u;
                        10,4,u; 10,6,u;
                        11,1,u; 11,3,u; 11,9,u; 11,9,u;
                        12,5,u;
                        
                        1,5,r; 1,6,r; 
                        3,2,r; 3,9,r; 
                        4,3,r; 4,4,r; 4,7,r; 4,8,r; 
                        6,1,r; 6,2,r; 6,9,r; 6,10,r; 
                        8,4,r; 8,7,r; 
                        9,3,r; 9,8,r; 
                        10,2,r; 10,5,r; 10,6,r; 10,9,r;
                        11,3,r; 11,4,r; 11,7,r; 11,8,r; 
                        
                        }
	pacman=p
	agent={p;Blinky}
        Position= {p,10,6; Blinky,1,1;}
	PreviousMove={Blinky,d; p,r}  
	Move<ct> = {Blinky,r} //Pacman has two possible moves

	Gold = {2,5}
}

structure winlose : PacmanVoc{
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..4}
	yCo = {1..4}

	pacman=p
	agent={p; Blinky; Pinky; Inky; Clyde}
	PreviousMove={p,d;Blinky,d;Pinky,d;Inky,d;Clyde,d}


	NoPos = {1,1; 1,2; 4,1; 4,2; 4,3; }

	Wall = {2,2,d}
	
	GameWon=true
	GameLost=true

	
}

structure win : PacmanVoc{
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..4}
	yCo = {1..4}

	pacman=p
	agent={p; Blinky; }
	PreviousMove={p,u;Blinky,u;}

	NoPos = {1,1; 1,2; 4,1; 4,2; 4,3; }
	Position={p,1,3;Blinky,1,4}

	Wall = {2,2,d}
	
	GameWon=true

	
}

structure lose : PacmanVoc{
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..4}
	yCo = {1..4}

	pacman=p
	agent={p; Blinky; }
	PreviousMove={p,u;Blinky,u;}

	NoPos = {1,1; 1,2; 4,1; 4,2; 4,3; }
	Position<ct> = {p,1,3}

	Wall = {2,2,d}
	
	GameLost=true
	Gold={}

	
}
 