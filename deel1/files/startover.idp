/**
 * Title: A new IDP source file
 * Author: jessa
 */


vocabulary PacmanVoc{

	type dir //We guarantee you that dir, Left, Right, Up, Down will always be correctly interpreted in structures. You should not check this.
	Down: dir
	Left: dir
	Right: dir
	Up: dir

	type xCo isa int
	type yCo isa int

	type agent //The ghosts and pacman
	pacman:agent

	NoPos(xCo,yCo) 
	Wall(xCo,yCo,dir)


	/*Van wat hieronder staat kan een deel gegeven zijn, een deel gevraagd*/
	Gold(xCo,yCo)
	GameLost
	GameWon
	Position(agent,xCo,yCo)
	
	PreviousMove(agent,dir)
	Move(agent,dir)
	
	/* Eigen predicaten */
	Transition(dir,xCo,yCo,xCo,yCo)
	OppositeDir(dir):dir
	IsWall(xCo,yCo,dir)
	Reach(xCo,yCo,xCo,yCo)
	Pos(xCo,yCo)
	GameEnded

}

theory PacmanTheory:PacmanVoc{
	// Transition, de relatie tussen verandering van coordinaten en richting.
	// Impliciet, wanneer er een transition bestaat, liggen twee vakjes naast elkaar.
	{
	!x1[xCo], y1[yCo], x2[xCo], y2[yCo]: Transition(Down ,x1,y1,x2,y2) <- x2=x1 & y2=-1+y1.
	!x1[xCo], y1[yCo], x2[xCo], y2[yCo]: Transition(Up   ,x1,y1,x2,y2) <- x2=x1 & y2= 1+y1.
	!x1[xCo], y1[yCo], x2[xCo], y2[yCo]: Transition(Left ,x1,y1,x2,y2) <- x2=-1+x1 & y2=y1.
	!x1[xCo], y1[yCo], x2[xCo], y2[yCo]: Transition(Right,x1,y1,x2,y2) <- x2= 1+x1 & y2=y1.
	}
							
	// OpositeDirection, uitdrukken dat twee richtingen elkaars tegengestellenden zijn
		OppositeDir(Left)=Right.
		OppositeDir(Up)=Down.
		!d[dir]:OppositeDir(OppositeDir(d))=d.
		
	// GameEnded: Het spel is gedaan, het is verloren of gewonnen
	GameEnded<=>GameLost|GameWon.
	
	// Pos: Een positie waar wel een vakje is
	{
	!x[xCo],y[yCo]:Pos(x,y)<-~NoPos(x,y).
	}
	
	// Wall predicaat symmetrisch maken
	{
		!x[xCo],y[yCo],d[dir]: IsWall(x,y,d) <- Wall(x,y,d).
		!x2[xCo],y2[yCo],d[dir]: IsWall(x2,y2,OppositeDir(d)) <- ?x1[xCo],y1[yCo]: IsWall(x1,y1,d) & Transition(d,x1,y1,x2,y2).
	}
	

	// Alle vakjes zijn aaneengesloten
	{
		! x[xCo],y[yCo] : Reach(x,y,x,y) <-Pos(x,y).
		! x1[xCo],y1[yCo],x2[xCo],y2[yCo] : Reach(x1,y1,x2,y2) <- ? d[dir] :Transition(d,x1,y1,x2,y2) 
																		& ~IsWall(x1,y1,d) & Pos(x1,y1) & Pos(x2,y2).
		! x1[xCo],y1[yCo],x2[xCo],y2[yCo] : Reach(x1,y1,x2,y2) <- ?x3[xCo],y3[yCo]:Reach(x1,y1,x3,y3)&Reach(x3,y3,x2,y2).
	}
	!x1[xCo],y1[yCo],x2[xCo],y2[yCo]:Pos(x1,y1)&Pos(x2,y2)<=>Reach(x1,y1,x2,y2).
	
	// GameLost en GameWon hebben de juiste interpretatie in functie v d andere predicaten
	~GameLost & ~ (? x[xCo],y[yCo] : Gold(x,y)) <=> GameWon.
	(? x[xCo],y[yCo], a[agent]: Position(pacman,x,y) & Position(a,x,y) & ~a=pacman)<=>GameLost.
	
	// Iedereen is op exact 1 plaats
	!a[agent]:?x[xCo],y[yCo]:Position(a,x,y).
	!a[agent],x1[xCo],y1[yCo],x2[xCo],y2[yCo]:Position(a,x1,y1)&Position(a,x2,y2)
			=> x1=x2&y1=y2.
	
	// Niemand staat op plaatsen waar geen vakje is
	!a[agent],x[xCo],y[yCo]:Position(a,x,y)=>Pos(x,y).
	
	// Er kan enkel goud liggen op plaatsen waar een vakje is
	! x[xCo],y[yCo] : Gold(x,y) => Pos(x,y).
	
	// Niemand beweegt door muren
	! x[xCo],y[yCo],a[agent],d[dir]:(IsWall(x,y,d)&Position(a,x,y)=>~Move(a,d)).
	
	// Iedereen kan hoogstens in 1 richting tegelijk bewegen
	! a[agent] : ! d1[dir],d2[dir] : ( Move(a,d1) & Move(a,d2) ) => d1=d2.
	
	// Ghosts kunnen niet omkeren
	! a[agent],d [dir], prevD[dir] : a=pacman | ( Move(a,d) & PreviousMove(a,prevD)=>~prevD=OppositeDir(d)).
	
	// Pacman laat geen goud liggen.
	!p[agent],d[dir],x1[xCo],y1[yCo],x2[xCo],y2[yCo]:p=pacman&PreviousMove(p,d)&Position(p,x2,y2)&Transition(d,x1,y1,x2,y2)
				=> ~Gold(x1,y1).

	// Afhankelijk van of het spel al gedaan is moet iedereen bewegen/mag niemand bewegen
	GameEnded<=>~?a[agent],d[dir]:Move(a,d).
	
	// Niemand beweegt van het bord af
	!a[agent],x1[xCo],y1[yCo],x2[xCo],y2[yCo],d[dir]:Position(a,x1,y1)&Move(a,d)&Transition(d,x1,y1,x2,y2)=>Pos(x2,y2).
}



 
 

/*
Some instance for the time-independent Pacman game.
*/
include <mx>

procedure main() {
	local strucs={
//		{turnGhost, "turning ghost",0},
//		{oneMoveDir, "OneMoveDirection",2} ,
//		{allPos, "allPos", 3 } ,
//		{mini, "mini", 2 } ,
		{split, "split", 0 } ,
		{invalidGold, "invalidGold", 0}, 
		{cheater2, "cheater2", 0 } ,
		{cheater3, "cheater3", 0 } ,
//		{huge, "huge", 2},
		{winlose, "winlose", 0 } ,
		{win, "win", 1 } ,
		{lose, "lose", 1 } ,
		{noGoldLeft,"noGoldLeft",0},
		{goldNoPos,"goldNoPos",0},
	}


//	stdoptions.liftedunitpropagation=false
//	stdoptions.groundwithbounds=false
	
	
	for i = 1, #strucs do
		local curr = strucs[i]
		local struc = curr[1]
		local name = curr[2]
		local expected = curr[3]
		stdoptions.nbmodels = expected + 1
		print("Veryfing", name)
		local models = modelexpand(PacmanTheory,curr[1])
		//printcore(PacmanTheory,curr[1])
		local modelsfound = #models
		if modelsfound > expected then
			print(">>>>>>> Verification failed. Found too many models for", name)
			printmodels(models)
		elseif modelsfound < expected then
			print(">>>>>>> Verification failed. Found too few models for", name)
			printmodels(models)
		else
			print("Verification succeeded for", name)
		end
	end
	
	


}


structure turnGhost : PacmanVoc{
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..4}
	yCo = {1..4}

	pacman=p
	agent={p; Blinky; Pinky; Inky; Clyde}
	PreviousMove={p,d;Blinky,d;Pinky,d;Inky,d;Clyde,d}
	Move={Pinky,u}

	NoPos = {}

	Wall = {2,2,r}

}


structure oneMoveDir : PacmanVoc{
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..4}
	yCo = {1..4}

	pacman=p
	agent={p;Pinky}
	PreviousMove ={Pinky,d}


	NoPos = {}

	Wall = {2,2,r}

}


structure allPos : PacmanVoc{
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..4}
	yCo = {1..4}

	pacman=p
	agent={p; Blinky; Pinky; Inky; Clyde}
	PreviousMove={p,d;Blinky,d;Pinky,d;Inky,d;Clyde,d}

	NoPos = {}

	Wall = {2,2,r}

}


structure mini : PacmanVoc{
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..3}
	yCo = {1}

	pacman=p
	agent={p; Blinky; Pinky; Inky; Clyde}
	PreviousMove={p,d;Blinky,d;Pinky,d;Inky,d;Clyde,d}

	NoPos = {}

	Wall = {1,1,l}

}

structure split : PacmanVoc{
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..4}
	yCo = {1..4}

	pacman=p
	agent={p; Blinky; Pinky; Inky; Clyde}
	PreviousMove={p,d;Blinky,d;Pinky,d;Inky,d;Clyde,d}

	NoPos = {1,2;2,2;3,2;4,2}

	Wall = {}

}

structure invalidGold : PacmanVoc{
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..4}
	yCo = {1..4}

	pacman=p
	agent={p; Blinky; Pinky; Inky; Clyde}
	PreviousMove={p,d;Blinky,d;Pinky,d;Inky,d;Clyde,d}

	NoPos = {1,1; 1,2; 1,3; 1,4; 2,1; 4,3; 4,4; 2,4; 3,4}

	Wall = {}

	Gold={2,2;1,4}

}


structure cheater2 : PacmanVoc{
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..4}
	yCo = {1..4}

	pacman=p
	agent={p; Blinky; Pinky; Inky; Clyde}
	PreviousMove={p,d;Blinky,d;Pinky,d;Inky,d;Clyde,d}

	NoPos = {1,1; 1,2; 4,1; 4,2; 4,3; 4,4; 2,4; 3,4}

	Wall = {2,2,d}
	
	Position<ct> = {p,2,2}

	Move<ct> = {p,d}

	
}

structure cheater3 : PacmanVoc{
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..4}
	yCo = {1..4}

	pacman=p
	agent={p; Blinky; Pinky; Inky; Clyde}
	PreviousMove={p,d;Blinky,d;Pinky,d;Inky,d;Clyde,d}

	NoPos = {1,1; 1,2; 4,1; 4,2; 4,3; }

	Wall = {2,2,d}
	
	Position<ct> = {p,4,4}

	Move<ct> = {p,d}

	
}

structure huge : PacmanVoc{
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

        xCo = {1..12}
        yCo = {1..10}
        NoPos = {2,3;2,8;5,1;5,10;6,5;6,6;7,5;7,6;8,1;9,1;8,10;9,10}
        Wall = {
                        2,1,u; 2,4,u; 2,6,u; 2,9,u; 
                        3,1,u; 3,4,u; 3,6,u; 3,9,u; 3,5,u;
                        4,3,u; 4,5,u; 4,7,u;
                        5,3,u; 5,7,u;
                        6,2,u; 6,8,u;
                        7,2,u; 7,8,u;
                        8,3,u; 8,7,u;
                        9,2,u; 9,5,u; 9,8,u;
                        10,4,u; 10,6,u;
                        11,1,u; 11,3,u; 11,9,u; 11,9,u;
                        12,5,u;
                        
                        1,5,r; 1,6,r; 
                        3,2,r; 3,9,r; 
                        4,3,r; 4,4,r; 4,7,r; 4,8,r; 
                        6,1,r; 6,2,r; 6,9,r; 6,10,r; 
                        8,4,r; 8,7,r; 
                        9,3,r; 9,8,r; 
                        10,2,r; 10,5,r; 10,6,r; 10,9,r;
                        11,3,r; 11,4,r; 11,7,r; 11,8,r; 
                        
                        }
	pacman=p
	agent={p;Blinky}
        Position= {p,10,6; Blinky,1,1;}
	PreviousMove={Blinky,d; p,r}  
	Move<ct> = {Blinky,r} //Pacman has two possible moves

	Gold = {2,5}
}

structure winlose : PacmanVoc{
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..4}
	yCo = {1..4}

	pacman=p
	agent={p; Blinky; Pinky; Inky; Clyde}
	PreviousMove={p,d;Blinky,d;Pinky,d;Inky,d;Clyde,d}


	NoPos = {1,1; 1,2; 4,1; 4,2; 4,3; }

	Wall = {2,2,d}
	
	GameWon=true
	GameLost=true

	
}

structure win : PacmanVoc{
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..4}
	yCo = {1..4}

	pacman=p
	agent={p; Blinky; }
	PreviousMove={p,u;Blinky,u;}

	NoPos = {1,1; 1,2; 4,1; 4,2; 4,3; }
	Position={p,1,3;Blinky,1,4}

	Wall = {2,2,d}
	
	GameWon=true

	
}

structure lose : PacmanVoc{
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..4}
	yCo = {1..4}

	pacman=p
	agent={p; Blinky; }
	PreviousMove={p,u;Blinky,u;}

	NoPos = {1,1; 1,2; 4,1; 4,2; 4,3; }
	Position<ct> = {p,1,3}

	Wall = {2,2,d}
	
	GameLost=true
	Gold={}

	
}

structure noGoldLeft : PacmanVoc{
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..4}
	yCo = {1..4}

	pacman=p
	agent={p; Blinky; }
	PreviousMove={p,u;Blinky,u;}

	NoPos = {1,1; 1,2; 4,1; 4,2; 4,3; }
	Position<ct> = {p,2,3}

	Wall = {2,2,d}
	
	Gold={2,2}
}

structure goldNoPos: PacmanVoc{
	dir = {u;d;l;r}
	Up=u
	Down=d
	Left=l
	Right=r

	xCo = {1..4}
	yCo = {1..4}

	pacman=p
	agent={p; Blinky; }
	PreviousMove={p,u;Blinky,u;}

	NoPos = {1,1; 1,2; 4,1; 4,2; 4,3; }
	Position<ct> = {p,2,3}

	Wall = {2,2,d}
	
	Gold={1,2}
}
 